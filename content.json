[{"title":"CommandJS AMD CMD读书笔记","date":"2017-02-22T11:38:33.000Z","path":"2017/02/22/CommandJS-AMD-CMD读书笔记/","text":"CommandJS1.规范CommandJS规范要求每个文件都是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类都是私有的，对其他文件不可见。而如果要调用每个模块，可以设置为global的属性，但是并不可取。所以规范规定module为模块本身，module.exports为模块的对外接口，加载模块。123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; require用于加载模块。 1234var example = require(&apos;./example.js&apos;);console.log(example.x); // 5console.log(example.addX(1)); // 6 所有代码都运行在模块作用域，不会污染全局作用域。模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。模块加载的顺序，按照其在代码中出现的顺序。 AMD为什么要用AMD规范？因为CommendJS规范开始作用于服务器端，是同步的。但是如果需要在浏览器端请求模块化的代码，就不能使用同步的。所以出现了AMD规范。通过回调函数异步加载模块。被依赖的模块在依赖模块前加载。 1var example = require([&apos;Math&apos;],function(Math)&#123;&#125;); 衍生出了require.js以及curl.js CMD代表为sea.js。 1define（） CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 区别AMD与CMD都用与浏览器端，但是AMD是提前执行，CMD是延迟执行。AMD推崇依赖前置，CMD推崇依赖就近。AMD的API一个多用，CMD分的更为清楚","tags":[{"name":"代码模块化笔记","slug":"代码模块化笔记","permalink":"http://HeliumLau.github.io/tags/代码模块化笔记/"}]},{"title":"文档元信息meta标签","date":"2017-02-21T08:22:53.000Z","path":"2017/02/21/文档元信息meta标签/","text":"定义和用法标签位于文档头部，不包含任何内容，提供有关页面的元信息，例如作者、日期和时间、网页描述、关键词以及页面刷新等。 组成Meta标签可分为两大部分：HTTP-EQUIV和NAME变量。实例： 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt; 123456781、&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gb_2312-80&quot;&gt;和&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot;&gt;用以说明主页制作所使用的文字以及语言；又如英文是ISO-8859-1字符集，还有BIG5、utf-8、shift-Jis、Euc、Koi8-2等字符集；2、&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;n;url=http://yourlink&quot;&gt;定时让网页在指定的时间n内，跳转到你的页面；3、&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Mon,12 May 2001 00:20:00 GMT&quot;&gt;可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式；4、&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；5、&lt;meta http-equiv=&quot;set-cookie&quot; content=&quot;Mon,12 May 2001 00:20:00 GMT&quot;&gt;cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；6、&lt;meta http-equiv=&quot;Pics-label&quot; content=&quot;&quot;&gt;网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的；7、&lt;meta http-equiv=&quot;windows-Target&quot; content=&quot;_top&quot;&gt;强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；8、&lt;meta http-equiv=&quot;Page-Enter&quot; content=&quot;revealTrans（duration=10,transition= 50）&quot;&gt;和&lt;meta http-equiv=&quot;Page-Exit&quot; content=&quot;revealTrans（duration=20，transition=6）&quot;&gt;设定进入和离开页面时的特殊效果，这个功能即FrontPage中的&quot;格式/网页过渡&quot;，不过所加的页面不能够是一个frame页面。 自己描述的话就是 1&lt;meta name=&quot;&quot; content=&quot;description&quot;&gt; 有个重定向的设定：1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5;url=http://www.w3school.com.cn&quot; /&gt; 有个设置窗口大小与设备大小一致的设定 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;","tags":[{"name":"Html","slug":"Html","permalink":"http://HeliumLau.github.io/tags/Html/"}]},{"title":"犀牛经-脚本化CSS","date":"2017-02-17T02:04:07.000Z","path":"2017/02/17/犀牛经-脚本化CSS/","text":"脚本化CSS层叠来自于：1.Web浏览器的默认样式表2.文档的样式表3.每个独立的HTML元素的style属性从上到下优先级提升。 非标准属性，即浏览器厂商前缀：FF -moz-Chrome -webkit-IE -ms- 关于Z-index的使用需要注意：z-index只对兄弟元素，即同一个容器下的子元素应用堆叠效果。 对于新属性text-shadow，在不支持其属性的浏览器中，同样可以通过设置定位来实现阴影效果。比如： &lt;span style=&quot;position:relative&quot;&gt; XXXX &lt;span style=&quot;position: absolute&quot;&gt; XXXX &lt;/span&gt; &lt;/span&gt; 关于透明度opacity在IE中用法 filter： alpha（opacity=75） CSS动画通过setTimeout以及setInterval来修改元素内联样式产生动画。 查询计算出的样式window.getComputedStyle(element, null); 查询、插入与删除样式表规则document.styleSheets[0].cssRules[0];(IE属性名是rules)styleSheets[0]还有insertRule（）和deleteRule（）属性。","tags":[{"name":"犀牛经-读书笔记","slug":"犀牛经-读书笔记","permalink":"http://HeliumLau.github.io/tags/犀牛经-读书笔记/"}]},{"title":"页面元素位置的获取（参考阮一峰的博客）","date":"2017-02-13T02:37:52.000Z","path":"2017/02/13/页面元素位置的获取（参考阮一峰的博客）/","text":"一、网页的大小和浏览器窗口的大小网页的大小由网页的内容以及样式表来确定。而窗口大小由浏览器的可视区来决定（Viewport）。 二、获取网页的大小 12345678910111213function getViewport()&#123; if (document.compatMode == &quot;BackCompat&quot;)&#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125; &#125; 1）这个函数必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。 2）大多数情况下，都是document.documentElement.clientWidth返回正确值。但是，在IE6的quirks模式中，document.body.clientWidth返回正确的值，因此函数中加入了对文档模式的判断。 3）clientWidth和clientHeight都是只读属性，不能对它们赋值 三、获取网页大小的另一种方法function getPagearea(){123456789101112if (document.compatMode == &quot;BackCompat&quot;)&#123; return &#123; width: document.body.scrollWidth, height: document.body.scrollHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.scrollWidth, height: document.documentElement.scrollHeight &#125; &#125; &#125; 网页上的每个元素还有scrollHeight和scrollWidth属性，指包含滚动条在内的该元素的视觉面积。 那么，document对象的scrollHeight和scrollWidth属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。 1234567891011121314151617function getPagearea()&#123; if (document.compatMode == &quot;BackCompat&quot;)&#123; return &#123; width: Math.max(document.body.scrollWidth, document.body.clientWidth), height: Math.max(document.body.scrollHeight, document.body.clientHeight) &#125; &#125; else &#123; return &#123; width: Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth), height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight) &#125; &#125; &#125; 但是，这个函数有一个问题。如果网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。 四、获取网页元素的绝对位置下面两个函数可以用来获取绝对位置的横坐标和纵坐标。 1234567891011121314151617181920212223function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft; &#125; function getElementTop(element)&#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop; &#125; 由于在表格和iframe中，offsetParent对象未必等于父容器，所以上面的函数对于表格和iframe中的元素不适用。 五、获取网页元素的相对位置网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。 有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是document对象的scrollTop属性；滚动条滚动的水平距离是document对象的scrollLeft属性。 六、获取元素位置的快速方法getBoundingClientRect() 123var X= this.getBoundingClientRect().left; var Y =this.getBoundingClientRect().top; 七、jQuery下的位置获取方法 123456789101112131415alert($(window).height()); //浏览器当前窗口可视区域高度alert($(document).height()); //浏览器当前窗口文档的高度alert($(document.body).height());//浏览器当前窗口文档body的高度alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding marginalert($(window).width()); //浏览器当前窗口可视区域宽度alert($(document).width());//浏览器当前窗口文档对象宽度alert($(document.body).width());//浏览器当前窗口文档body的高度alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://HeliumLau.github.io/tags/JavaScript/"}]},{"title":"express试验","date":"2017-02-09T05:41:13.000Z","path":"2017/02/09/express试验/","text":"什么是Express？Express是Node.js的一个Web框架。Web应用程序有共同的模式，所以使用框架来构建经常事办功倍。为什么使用ExpressExpress是个轻量级的框架，这就意味着它不做太多假定，但却足以避免用户重新发明轮子。 创建一个基础的Express站点遇到了麻烦，通过指令npm install -g express安装了全局express，但是在指令express express_example时出现错误。于是使用另外一种方案，直接cd然后不安装全局对象npm install express，继续express创建，又失效了。 查询网络，猜测原因是版本更新了。@4.14.0，可以重新安装个express@3.5.0。 或者，还要安装一个命令工具npm install -g express-generator，然后用express创建一个工程express helloworld，创建好项目后还需要用npm进行添加依赖和启动cd helloworld，npm install，而且启动不再是node app.js 而是npm start。但是在创建依赖npm install的时候出现了问题，jade改名成了pug所以需要重新安装pug。（网上说还需要安装npm install -g pug-cli），于是用命令npm install -g pug下载pug模块，但是安装一直处于等待过程中。（国内防火墙的问题，可以翻墙下载）或者使用镜像。 探索Express打开了helloworld文件夹后，有以下文件：1.app.js是用来启动应用程序文件夹。2.node_modules用来保存package.json中定义并且已经安装的Node模块。3.package.json提高应用程序的信息。4.public提供给Web进行服务的公共文件夹。5.routes文件夹保存了定义了应用程序该响应页面的路由。6.views文件夹定义应用程序的布局。 jade是个基于缩进的模板引擎HTML和Jade比较 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;h1&gt;My holiday in Prague&lt;/h1&gt; &lt;p&gt;XXX&lt;/p&gt; &lt;img src=&apos;&apos; alt=&apos;&apos; /&gt;&lt;/div&gt; 1234.wrapper h1 My holiday in Prague p XXX img(src=&apos;&apos;,alt=&apos;&apos;) 可以看出来，Jade比HTML简洁，是采用缩进来定义HTML文档层次结构，在Jade中无需使用标记，编译模板的时候会自动加入&lt;&gt;字符，同样也不需要关闭HTML标记，在Jade生成HTML的时候会为我们关闭标记。 为什么要用Jade？因为它使得应用程序可以动态输出数据到HTML中。比如显示一组保存在数据库中的博客帖子，创建单一的模板用于显示不同的博客帖子，按变量的值更改页面的元素，创建可跨模板重用的页眉和页脚内容。 Jade定义页面结构section#wrapperp.highlightsection#wrapper.class-namep.first.section.third.fourth 12p span h1 Very important heading 1234p | Text can be over | many lines | after a pipe symbol Jade真正的能力在于操纵数据并输出数据到HTML中。两个特殊符号-：告诉随后的代码应当被执行。=：告诉解释器要对代码进行演算、转义和输出。例子： 12- var foo =bar;p I want to learn to use variables. Foo is #&#123;foo&#125;; 编译后就是： 1&lt;p&gt;I want to learn to use variables. Foo is bar!&lt;/p&gt; 12345678- users = [&apos;Sally&apos;,&apos;Joseph&apos;]- each user in users p= user 编译后是&lt;p&gt;Sally&lt;/p&gt;&lt;p&gt;Joseph&lt;/p&gt; 12- for user in users p= user 1234567- obj = &#123;first_name:&apos;George&apos;&#125;- each val, key in obj li #&#123;key&#125;:#&#123;val&#125;编译后是&lt;li&gt;first_name: George&lt;/li&gt; 条件 12345- awake = false- if (awake) p You are awake!Make coffee!- else p You are sleeping 内联JavaScript 12script alert(&apos;Hello world!&apos;) Mixin（类似类，可重用） 123456mixin users(users) ul each user in users li= user - users = [&apos;Tanya&apos;,&apos;Kim&apos;] mixin users(users) 还有页脚在views/includes 添加footer.jade将footer文件包含到 index.jade中 12h1 Jade Includes Exampleinclude includes/footer","tags":[{"name":"node.js","slug":"node-js","permalink":"http://HeliumLau.github.io/tags/node-js/"}]},{"title":"关于transform属性","date":"2017-02-09T03:11:33.000Z","path":"2017/02/09/关于transform属性/","text":"CSS3有个非常强大的工具 2D动画 transform，可作用于内联或者块状元素，该属性可以旋转、缩放和移动元素。 transform的基本语法1transform：none|&lt;transform-function&gt;[&lt;transform-function&gt;]*; 12345&lt;transform-function&gt; :matrix() 定义矩阵变换 translate() 移动元素 scale() 缩放元素 rotate() 旋转元素 skew() 倾斜元素 兼容写法： 1234-webkit-transform -moz-transform -o-transform 滤镜 一般写在伪类：hover里面 关于旋转在IE的实现语法： 1filter:progid:DXImageTransform.Microsoft.BasicImage(enabled=bEnabled,grayScale=bGray,mirror=bMirror,opacity=fOpacity,Xray=bXray) 1filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=3); 关于缩放在IE的实现（对不起，暂时无法实现）在其他浏览器中的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .test ul &#123; list-style: none; &#125; .test li &#123; float: left; width: 100px; background: #CCC; margin-left: 3px; line-height: 30px; &#125; .test a &#123; display: block; text-align: center; height: 30px; -webkit-transition: -webkit-transform .5s ease-in; -moz-transition: -moz-transform .5s ease-in; -o-transition: -o-transform .5s ease-in; transition: transform .5s ease-in; &#125; .test a:link &#123; color: #666; text-decoration: none; &#125; .test a:visited &#123; color: #666; text-decoration: none; &#125; .test a:hover &#123; color: #FFF; font-weight: bold; text-decoration: none; background-color: #000; -webkit-transform: scale(2); -moz-transform: scale(2); transform: scale(2); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 关于移动动画的实现（IE没有）关于倾斜动画的实现（IE没有）关于变形动画的实现自定义变形元素的变化默认是以对象的中心点为原点，也就是transform-origin默认值是50%，50%。元素的变化是否会影响到文档的其他元素？好像不会，但是等待继续挖掘。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://HeliumLau.github.io/tags/CSS/"}]},{"title":"CSS字体的导入","date":"2017-02-07T07:10:57.000Z","path":"2017/02/07/css字体导入/","text":"语法如下： @font-face { font-family: Myfontname; src: XXX; (.ttf;.eot) } p { font-family: Myfontname; } 例子： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; @font-face { font-family: &quot;ChinaStyle&quot;; src: url(ChinaStyle.ttf); } h1 { font-family: &quot;ChinaStyle&quot;; font-size: 4em; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;中国龙&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 注意一下，字体的后缀很重要，事关能不能再浏览器中正常显示 @font-face { font-family: &apos;icon-font&apos;; src:url(&apos;/assets/fonts/jiaicon.eot&apos;); src:url(&apos;/assets/fonts/jiaicon.eot&apos;) format(&apos;embedded-opentype&apos;), url(&apos;/assets/fonts/jiaicon.woff&apos;) format(&apos;woff&apos;), url(&apos;/assets/fonts/jiaicon.ttf&apos;) format(&apos;truetype&apos;), url(&apos;/assets/fonts/jiaicon.svg&apos;) format(&apos;svg&apos;); font-weight: normal; font-style: normal; } 除了格式外，好像还有其他因素会影响到字体的显示。比如说如果继续设置其他字体会导致显示无效。另外还有一个限制，那就是，中文导入字体不像英文字体，文件往往有几M，比较大。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://HeliumLau.github.io/tags/CSS/"}]},{"title":"基于github搭建hexo博客","date":"2017-02-06T13:36:25.000Z","path":"2017/02/06/基于github搭建hexo博客/","text":"准备工作1.安装Git2.安装Node.js3.有一个GitHub账号 搭建流程1.登录github网站，在github建立一个repository，名字必须为XXX.github.io，其中XXX是你的github账户名，例如：HeliumLau.github.io。 2.打开Command命令窗口，下载一个淘宝NPM镜像npm install -g cnpm --registry=https://registry.npm.taobao.org，用cnpm安装hexo框架cnpm install -g hexo-cli以及cnpm install hexo --save，可通过命令hexo -v查看版本以及是否安装成功。3.本地创建一个blog文件夹，任意路径。4.同样通过Command命令窗口，在对应blog文件夹路径下初始化hexo项目hexo init。创建完成后，cd到该目录下安装生成器cnpm install。5.要在本地建立博客就输入hexo s -g，再打开浏览器输入localhost：4000即可。但是，我们想要的是上线，可以在其他地方阅读该博客。6.为了支持github，还需要安装另外一个插件npm install hexo-deployer-git --save。7.我们需要配置项目目录下的_config.yml文件，打开它找到最后一行，我们把github的配置信息填上去。 1234deploy: type: git repo: https://github.com/HeliumLau/HeliumLau.github.io.git branch: master 8.当前路径输入命令行hexo d，按照指示输入账号密码即可登录，注意：密码输入并不会显示。这样一个博客就搭建完成啦！ 管理博客写文章输入创建文章命令，生成一个md文件(/blog/source/_posts/) 1$ hexo new &quot;hello&quot; 用编辑器打开hello.md文件编辑并保存。发布并更新博客hexo d -g。 删除文章把 /source/_posts 下的 Test01.md和public文件夹里的文章都删除，再删除db.json，输入命令行hexo clean,再生成hexo d -g。 更换主题可以从github或者其他地方找到优秀的主题，下载压缩包并解压到该blog的themes文件夹下，对站点配置文件以及主题配置文件进行配置。==结束后，一定要hexo clean清楚hexo缓存，要不上传看不到更新的效果。==","tags":[{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"http://HeliumLau.github.io/tags/搭建个人博客/"}]},{"title":"Flex Layout(转载自阮一峰的博客)","date":"2017-02-06T07:10:57.000Z","path":"2017/02/06/fortest/","text":"一、骰子的布局骰子的一面，最多可以放置9个点。下面，就来看看Flex如何实现，从1个点到9个点的布局。你可以到codepen查看Demo。如果不加说明，本节的HTML模板一律如下。 &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; 上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。 1.1 单项目首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。 .box { display: flex; } 设置项目的对齐方式，就能实现居中对齐和右对齐。 .box { display: flex; justify-content: center; } .box { display: flex; justify-content: flex-end; } .box { display: flex; align-items: center; } .box { display: flex; justify-content: center; align-items: flex-end; } .box { display: flex; justify-content: flex-end; align-items: flex-end; } 1.2 双项目 .box { display: flex; justify-content: space-between; } .box { display: flex; flex-direction: column; justify-content: space-between; } .box { display: flex; flex-direction: column; justify-content: space-between; align-items: center; } .box { display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end; } .box { display: flex; } .item:nth-child(2) { align-self: center; } .box { display: flex; justify-content: space-between; } .item:nth-child(2) { align-self: flex-end; } 1.3 三项目 .box { display: flex; } .item:nth-child(2) { align-self: center; } .item:nth-child(3) { align-self: flex-end; } 1.4 四项目 .box { display: flex; flex-wrap: wrap; justify-content: flex-end; align-content: space-between; } HTML代码如下。 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;column&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; CSS代码如下。 .box { display: flex; flex-wrap: wrap; align-content: space-between; } .column { flex-basis: 100%; display: flex; justify-content: space-between; } 1.5 六项目 .box { display: flex; flex-wrap: wrap; align-content: space-between; } .box { display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between; } HTML代码如下。 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; CSS代码如下。 .box { display: flex; flex-wrap: wrap; } .row{ flex-basis: 100%; display:flex; } .row:nth-child(2){ justify-content: center; } .row:nth-child(3){ justify-content: space-between; } 1.6 九项目 二、网格布局2.1 基本网格布局最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。HTML代码如下。 &lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;/div&gt; CSS代码如下。 .Grid { display: flex; } .Grid-cell { flex: 1; } 2.2 百分比布局某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。HTML代码如下。 &lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of3&quot;&gt;...&lt;/div&gt; &lt;/div&gt; .Grid { display: flex; } .Grid-cell { flex: 1; } .Grid-cell.u-full { flex: 0 0 100%; } .Grid-cell.u-1of2 { flex: 0 0 50%; } .Grid-cell.u-1of3 { flex: 0 0 33.3333%; } .Grid-cell.u-1of4 { flex: 0 0 25%; } 三、圣杯布局圣杯布局（Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。HTML代码如下。 &lt;body class=&quot;HolyGrail&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot;&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt; &lt;/body&gt; CSS代码如下。 .HolyGrail { display: flex; min-height: 100vh; flex-direction: column; } header, footer { flex: 1; } .HolyGrail-body { display: flex; flex: 1; } .HolyGrail-content { flex: 1; } .HolyGrail-nav, .HolyGrail-ads { /* 两个边栏的宽度设为12em */ flex: 0 0 12em; } .HolyGrail-nav { /* 导航放到最左边 */ order: -1; } 如果是小屏幕，躯干的三栏自动变为垂直叠加。 @media (max-width: 768px) { .HolyGrail-body { flex-direction: column; flex: 1; } .HolyGrail-nav, .HolyGrail-ads, .HolyGrail-content { flex: auto; } } 四、输入框的布局我们常常需要在输入框的前方添加提示，后方添加按钮。HTML代码如下。 &lt;div class=&quot;InputAddOn&quot;&gt; &lt;span class=&quot;InputAddOn-item&quot;&gt;...&lt;/span&gt; &lt;input class=&quot;InputAddOn-field&quot;&gt; &lt;button class=&quot;InputAddOn-item&quot;&gt;...&lt;/button&gt; &lt;/div&gt; CSS代码如下。 .InputAddOn { display: flex; } .InputAddOn-field { flex: 1; } 五、悬挂式布局有时，主栏的左侧或右侧，需要添加一个图片栏。HTML代码如下。 &lt;div class=&quot;Media&quot;&gt; &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;Media-body&quot;&gt;...&lt;/p&gt; &lt;/div&gt; CSS代码如下。 .Media { display: flex; align-items: flex-start; } .Media-figure { margin-right: 1em; } .Media-body { flex: 1; }","tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"http://HeliumLau.github.io/tags/CSS布局/"}]},{"title":"Hello World","date":"2017-02-06T06:26:35.163Z","path":"2017/02/06/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]